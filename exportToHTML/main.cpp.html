<html>
<head>
<title>main.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #999999; font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); font-style: italic; }
.s1 { color: rgb(0,0,0); }
.s2 { color: rgb(128,128,0); }
.s3 { color: rgb(0,128,0); font-weight: bold; }
.s4 { color: rgb(0,0,128); font-weight: bold; }
.s5 { color: rgb(0,0,255); }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
main.cpp</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">//Binary Search Tree</span><span class="s1"> 
 
</span><span class="s0">/* 
 * Created By Devashish Katoriya on 03-01-2017 
 */</span><span class="s1"> 
 
</span><span class="s2">#include</span><span class="s3">&lt;iostream&gt;</span><span class="s1"> 
 
</span><span class="s4">using namespace </span><span class="s1">std; 
 
</span><span class="s2">#define </span><span class="s1">LIMIT </span><span class="s5">200</span><span class="s1"> 
 
</span><span class="s4">class </span><span class="s1">node                                                          </span><span class="s0">//Node Class</span><span class="s1"> 
{ 
</span><span class="s4">public </span><span class="s1">: 
    </span><span class="s4">int </span><span class="s1">data; 
    node *LChild,*RChild; 
}; 
 
</span><span class="s4">template</span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">T&gt; 
</span><span class="s4">class </span><span class="s1">stack                                                         </span><span class="s0">//Stack Class</span><span class="s1"> 
{ 
    T arr[LIMIT]; 
    </span><span class="s4">int </span><span class="s1">top; 
</span><span class="s4">public </span><span class="s1">: 
    stack() 
    { 
        top = </span><span class="s5">0</span><span class="s1">; 
    } 
    </span><span class="s4">void </span><span class="s1">push(T s) 
    { 
        </span><span class="s4">if</span><span class="s1">(!isFull()) 
        { 
            arr[top] = s; 
            top++; 
        } 
        </span><span class="s4">else</span><span class="s1"> 
        { 
            cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Stack Overflow!&quot;</span><span class="s1">; 
        } 
    } 
    T pop() 
    { 
        </span><span class="s4">if</span><span class="s1">(!isEmpty()) 
        { 
            </span><span class="s4">return </span><span class="s1">arr[--top]; 
        } 
        </span><span class="s4">else</span><span class="s1"> 
        { 
            cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Stack Underflow!&quot;</span><span class="s1">; 
        } 
    } 
    </span><span class="s4">bool </span><span class="s1">isEmpty() 
    { 
        </span><span class="s4">return </span><span class="s1">top == </span><span class="s5">0</span><span class="s1">; 
    } 
    </span><span class="s4">bool </span><span class="s1">isFull() 
    { 
        </span><span class="s4">return </span><span class="s1">top == LIMIT; 
    } 
}; 
 
</span><span class="s4">class </span><span class="s1">binary_search_tree                                                    </span><span class="s0">//Tree Class</span><span class="s1"> 
{ 
    node *root; 
    node *create(); 
    </span><span class="s4">int </span><span class="s1">count,lCount; 
</span><span class="s4">public </span><span class="s1">: 
    binary_search_tree() 
    { 
        root = NULL; 
        count = </span><span class="s5">0</span><span class="s1">; 
    } 
    node *retRoot() 
    { 
        </span><span class="s4">return </span><span class="s1">root; 
    } 
    </span><span class="s4">int </span><span class="s1">retSize() 
    { 
        </span><span class="s4">return </span><span class="s1">count; 
    } 
    </span><span class="s4">int </span><span class="s1">retLeaves() 
    { 
        lCount = </span><span class="s5">0</span><span class="s1">; 
        leaves(root); 
        </span><span class="s4">return </span><span class="s1">lCount; 
    } 
    </span><span class="s4">void </span><span class="s1">clr() 
    { 
        root = NULL; 
        count = </span><span class="s5">0</span><span class="s1">; 
    } 
    </span><span class="s4">bool </span><span class="s1">isEmpty() 
    { 
        </span><span class="s4">return </span><span class="s1">root == NULL; 
    } 
    </span><span class="s4">void </span><span class="s1">construct(); 
    </span><span class="s4">void </span><span class="s1">inOrder(node *); 
    </span><span class="s4">void </span><span class="s1">preOrder(node *); 
    </span><span class="s4">void </span><span class="s1">postOrder(node *); 
    </span><span class="s4">void </span><span class="s1">in_itr(node *); 
    </span><span class="s4">void </span><span class="s1">pre_itr(node *); 
    </span><span class="s4">void </span><span class="s1">post_itr(node *); 
    </span><span class="s4">bool </span><span class="s1">search(</span><span class="s4">int</span><span class="s1">); 
    </span><span class="s4">void </span><span class="s1">remove(</span><span class="s4">int</span><span class="s1">); 
    </span><span class="s4">int </span><span class="s1">height(node *); 
    </span><span class="s4">void </span><span class="s1">leaves(node *); 
    </span><span class="s4">void </span><span class="s1">swap(node *); 
}; 
 
node *binary_search_tree::create()                                          </span><span class="s0">//create()</span><span class="s1"> 
{ 
    node *s; 
    s = </span><span class="s4">new </span><span class="s1">node; 
    </span><span class="s4">if</span><span class="s1">(s==NULL) 
    { 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Memory Not Allocated!&quot;</span><span class="s1">; 
        </span><span class="s4">return </span><span class="s1">NULL; 
    } 
    cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Enter value of Node : &quot;</span><span class="s1">; 
    cin&gt;&gt;s-&gt;data; 
    s-&gt;LChild = NULL; 
    s-&gt;RChild = NULL; 
    count++; 
 
    </span><span class="s4">return </span><span class="s1">s; 
} 
 
</span><span class="s4">void </span><span class="s1">binary_search_tree::construct()                                        </span><span class="s0">//construct()</span><span class="s1"> 
{ 
    node *temp,*p; 
    temp = create(); 
    </span><span class="s4">if</span><span class="s1">(isEmpty()) 
    { 
        root = temp; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Root Inserted!&quot;</span><span class="s1">; 
    } 
    </span><span class="s4">else</span><span class="s1"> 
    { 
        p = root; 
        </span><span class="s4">while</span><span class="s1">(p!=NULL) 
        { 
            </span><span class="s4">if</span><span class="s1">(temp-&gt;data&lt;p-&gt;data) 
            { 
                </span><span class="s4">if</span><span class="s1">(p-&gt;LChild==NULL) 
                { 
                    p-&gt;LChild = temp; 
                    cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Element Inserted!&quot;</span><span class="s1">; 
                    </span><span class="s4">break</span><span class="s1">; 
                } 
                </span><span class="s4">else</span><span class="s1"> 
                { 
                    p = p-&gt;LChild; 
                } 
            } 
            </span><span class="s4">else if </span><span class="s1">(temp-&gt;data&gt;p-&gt;data) 
            { 
                </span><span class="s4">if</span><span class="s1">(p-&gt;RChild==NULL) 
                { 
                    p-&gt;RChild = temp; 
                    cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Element Inserted!&quot;</span><span class="s1">; 
                    </span><span class="s4">break</span><span class="s1">; 
                } 
                </span><span class="s4">else</span><span class="s1"> 
                { 
                    p = p-&gt;RChild; 
                } 
            } 
            </span><span class="s4">else</span><span class="s1"> 
            { 
                cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Entry already Exist&quot;</span><span class="s1">; 
                count--; 
                </span><span class="s4">break</span><span class="s1">; 
            } 
        } 
    } 
} 
 
</span><span class="s4">void </span><span class="s1">binary_search_tree::remove(</span><span class="s4">int </span><span class="s1">d) 
{ 
    </span><span class="s0">//Locate the element</span><span class="s1"> 
    </span><span class="s4">bool </span><span class="s1">found = </span><span class="s4">false</span><span class="s1">; 
    </span><span class="s4">if</span><span class="s1">(isEmpty()) 
    { 
        cout&lt;&lt;</span><span class="s3">&quot; This Tree is empty! &quot;</span><span class="s1">&lt;&lt;endl; 
        </span><span class="s4">return</span><span class="s1">; 
    } 
    node *curr; 
    node *parent=NULL; 
    curr = root; 
    </span><span class="s4">while</span><span class="s1">(curr != NULL) 
    { 
        </span><span class="s4">if</span><span class="s1">(curr-&gt;data == d) 
        { 
            found = </span><span class="s4">true</span><span class="s1">; 
            </span><span class="s4">break</span><span class="s1">; 
        } 
        </span><span class="s4">else</span><span class="s1"> 
        { 
            parent = curr; 
            </span><span class="s4">if</span><span class="s1">(d&gt;curr-&gt;data) curr = curr-&gt;RChild; 
            </span><span class="s4">else </span><span class="s1">curr = curr-&gt;LChild; 
        } 
    } 
    </span><span class="s4">if</span><span class="s1">(!found) 
    { 
        cout&lt;&lt;</span><span class="s3">&quot; Data not found! &quot;</span><span class="s1">&lt;&lt;endl; 
        </span><span class="s4">return</span><span class="s1">; 
    } 
     
     
    </span><span class="s0">// 3 cases :</span><span class="s1"> 
    </span><span class="s0">// 1. We're removing a leaf node</span><span class="s1"> 
    </span><span class="s0">// 2. We're removing a node with a single child</span><span class="s1"> 
    </span><span class="s0">// 3. we're removing a node with 2 children</span><span class="s1"> 
     
    </span><span class="s0">// Node with single child</span><span class="s1"> 
    </span><span class="s4">if</span><span class="s1">((curr-&gt;LChild == NULL &amp;&amp; curr-&gt;RChild != NULL)|| (curr-&gt;LChild != NULL &amp;&amp; curr-&gt;RChild == NULL)) 
    { 
        </span><span class="s4">if</span><span class="s1">(curr-&gt;LChild == NULL &amp;&amp; curr-&gt;RChild != NULL) 
        { 
            </span><span class="s4">if</span><span class="s1">(parent-&gt;LChild == curr) 
            { 
                parent-&gt;LChild = curr-&gt;RChild; 
                </span><span class="s4">delete </span><span class="s1">curr; 
            } 
            </span><span class="s4">else</span><span class="s1"> 
            { 
                parent-&gt;RChild = curr-&gt;RChild; 
                </span><span class="s4">delete </span><span class="s1">curr; 
            } 
        } 
        </span><span class="s4">else </span><span class="s0">// left child present, no right child</span><span class="s1"> 
        { 
            </span><span class="s4">if</span><span class="s1">(parent-&gt;LChild == curr) 
            { 
                parent-&gt;LChild = curr-&gt;LChild; 
                </span><span class="s4">delete </span><span class="s1">curr; 
            } 
            </span><span class="s4">else</span><span class="s1"> 
            { 
                parent-&gt;RChild = curr-&gt;LChild; 
                </span><span class="s4">delete </span><span class="s1">curr; 
            } 
        } 
        </span><span class="s4">return</span><span class="s1">; 
    } 
     
    </span><span class="s0">//We're looking at a leaf node</span><span class="s1"> 
    </span><span class="s4">if</span><span class="s1">( curr-&gt;LChild == NULL &amp;&amp; curr-&gt;RChild == NULL) 
    { 
        </span><span class="s4">if</span><span class="s1">(parent-&gt;LChild == curr) parent-&gt;LChild = NULL; 
        </span><span class="s4">else </span><span class="s1">parent-&gt;RChild = NULL; 
        </span><span class="s4">delete </span><span class="s1">curr; 
        </span><span class="s4">return</span><span class="s1">; 
    } 
     
     
    </span><span class="s0">//Node with 2 children</span><span class="s1"> 
    </span><span class="s0">// replace node with smallest value in right subtree</span><span class="s1"> 
    </span><span class="s4">if </span><span class="s1">(curr-&gt;LChild != NULL &amp;&amp; curr-&gt;RChild != NULL) 
    { 
        node *chkr; 
        chkr = curr-&gt;RChild; 
        </span><span class="s4">if</span><span class="s1">((chkr-&gt;LChild == NULL) &amp;&amp; (chkr-&gt;RChild == NULL)) 
        { 
            curr = chkr; 
            </span><span class="s4">delete </span><span class="s1">chkr; 
            curr-&gt;RChild = NULL; 
        } 
        </span><span class="s4">else </span><span class="s0">// right child has children</span><span class="s1"> 
        { 
            </span><span class="s0">//if the node's right child has a left child</span><span class="s1"> 
            </span><span class="s0">// Move all the way down left to locate smallest element</span><span class="s1"> 
             
            </span><span class="s4">if</span><span class="s1">((curr-&gt;RChild)-&gt;LChild != NULL) 
            { 
                node *lcurr; 
                node *lcurrp; 
                lcurrp = curr-&gt;RChild; 
                lcurr = (curr-&gt;RChild)-&gt;LChild; 
                </span><span class="s4">while</span><span class="s1">(lcurr-&gt;LChild != NULL) 
                { 
                    lcurrp = lcurr; 
                    lcurr = lcurr-&gt;LChild; 
                } 
                curr-&gt;data = lcurr-&gt;data; 
                </span><span class="s4">delete </span><span class="s1">lcurr; 
                lcurrp-&gt;LChild = NULL; 
            } 
            </span><span class="s4">else</span><span class="s1"> 
            { 
                node *tmp; 
                tmp = curr-&gt;RChild; 
                curr-&gt;data = tmp-&gt;data; 
                curr-&gt;RChild = tmp-&gt;RChild; 
                </span><span class="s4">delete </span><span class="s1">tmp; 
            } 
             
        } 
        </span><span class="s4">return</span><span class="s1">; 
    } 
     
} 
 
</span><span class="s4">void </span><span class="s1">binary_search_tree::in_itr(node *s1)                               </span><span class="s0">//In order Iterative</span><span class="s1"> 
{ 
    node *temp; 
    temp = s1; 
    stack &lt;node *&gt;s; 
    </span><span class="s4">while</span><span class="s1">(</span><span class="s5">1</span><span class="s1">) 
    { 
        </span><span class="s4">while</span><span class="s1">(temp!=NULL) 
        { 
            s.push(temp); 
            temp = temp-&gt;LChild; 
        } 
        </span><span class="s4">if</span><span class="s1">(s.isEmpty()) 
            </span><span class="s4">return</span><span class="s1">; 
        temp = s.pop(); 
        cout&lt;&lt;temp-&gt;data; 
        temp = temp-&gt;RChild; 
    } 
} 
 
</span><span class="s4">void </span><span class="s1">binary_search_tree::inOrder(node *s1)                              </span><span class="s0">//in order()</span><span class="s1"> 
{ 
    </span><span class="s4">if</span><span class="s1">(s1!=NULL) 
    { 
        inOrder(s1-&gt;LChild); 
        cout&lt;&lt;s1-&gt;data&lt;&lt;</span><span class="s3">&quot;,&quot;</span><span class="s1">; 
        inOrder(s1-&gt;RChild); 
    } 
 
} 
 
</span><span class="s4">void </span><span class="s1">binary_search_tree::preOrder(node *s1)                         </span><span class="s0">//pre order()</span><span class="s1"> 
{ 
    </span><span class="s4">if</span><span class="s1">(s1!=NULL) 
    { 
        preOrder(s1-&gt;LChild); 
        preOrder(s1-&gt;RChild); 
        cout&lt;&lt;s1-&gt;data&lt;&lt;</span><span class="s3">&quot;,&quot;</span><span class="s1">; 
    } 
 
} 
 
</span><span class="s4">void </span><span class="s1">binary_search_tree::pre_itr(node *R)                               </span><span class="s0">//Pre order Iterative</span><span class="s1"> 
{ 
    node *temp; 
    temp = R; 
    stack &lt;node *&gt;s; 
    </span><span class="s4">while</span><span class="s1">(</span><span class="s5">1</span><span class="s1">) 
    { 
        </span><span class="s4">while</span><span class="s1">(temp!=NULL) 
        { 
            cout&lt;&lt;temp-&gt;data&lt;&lt;</span><span class="s3">&quot;,&quot;</span><span class="s1">; 
            s.push(temp); 
            temp = temp-&gt;LChild; 
        } 
        </span><span class="s4">if</span><span class="s1">(s.isEmpty()) 
            </span><span class="s4">return</span><span class="s1">; 
        temp = s.pop(); 
        temp = temp-&gt;RChild; 
    } 
} 
 
</span><span class="s4">void </span><span class="s1">binary_search_tree::postOrder(node *s)                         </span><span class="s0">//post order()</span><span class="s1"> 
{ 
    </span><span class="s4">if</span><span class="s1">(s!=NULL) 
    { 
        cout&lt;&lt;s-&gt;data&lt;&lt;</span><span class="s3">&quot;,&quot;</span><span class="s1">; 
        postOrder(s-&gt;LChild); 
        postOrder(s-&gt;RChild); 
    } 
} 
 
</span><span class="s4">void </span><span class="s1">binary_search_tree::post_itr(node *r)                              </span><span class="s0">//Post order Iterative</span><span class="s1"> 
{ 
    node *temp; 
    temp = r; 
    stack &lt;node *&gt;s; 
    stack &lt;</span><span class="s4">char</span><span class="s1">&gt;s2; 
    </span><span class="s4">char </span><span class="s1">flag; 
 
    </span><span class="s4">while</span><span class="s1">(</span><span class="s5">1</span><span class="s1">) 
    { 
        </span><span class="s4">while</span><span class="s1">(temp!=NULL) 
        { 
            s.push(temp); 
            s2.push(</span><span class="s3">'L'</span><span class="s1">); 
            temp = temp-&gt;LChild; 
        } 
        </span><span class="s4">if</span><span class="s1">(s.isEmpty()) 
            </span><span class="s4">return</span><span class="s1">; 
        temp = s.pop(); 
        flag = s2.pop(); 
        </span><span class="s4">if</span><span class="s1">(flag==</span><span class="s3">'R'</span><span class="s1">) 
        { 
            cout&lt;&lt;temp-&gt;data&lt;&lt;</span><span class="s3">&quot;,&quot;</span><span class="s1">; 
            temp = NULL; 
        } 
        </span><span class="s4">else</span><span class="s1"> 
        { 
            s.push(temp); 
            s2.push(</span><span class="s3">'R'</span><span class="s1">); 
            temp = temp-&gt;RChild; 
        } 
    } 
} 
 
</span><span class="s4">bool </span><span class="s1">binary_search_tree::search(</span><span class="s4">int </span><span class="s1">key)                                        </span><span class="s0">//search()</span><span class="s1"> 
{ 
    node *p; 
    </span><span class="s4">if</span><span class="s1">(isEmpty()) 
    { 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Empty tree!&quot;</span><span class="s1">; 
        </span><span class="s4">return false</span><span class="s1">; 
    } 
    </span><span class="s4">else</span><span class="s1"> 
    { 
        p = root; 
        </span><span class="s4">while</span><span class="s1">(p!=NULL) 
        { 
            </span><span class="s4">if</span><span class="s1">(key&lt;p-&gt;data) 
            { 
                </span><span class="s4">if</span><span class="s1">(p-&gt;LChild==NULL) 
                { 
                    </span><span class="s4">return false</span><span class="s1">; 
                } 
                </span><span class="s4">else</span><span class="s1"> 
                { 
                    p = p-&gt;LChild; 
                } 
            } 
            </span><span class="s4">else if </span><span class="s1">(key&gt;p-&gt;data) 
            { 
                </span><span class="s4">if</span><span class="s1">(p-&gt;RChild==NULL) 
                { 
                    </span><span class="s4">return false</span><span class="s1">; 
                } 
                </span><span class="s4">else</span><span class="s1"> 
                { 
                    p = p-&gt;RChild; 
                } 
            } 
            </span><span class="s4">else</span><span class="s1"> 
            { 
                </span><span class="s4">return true</span><span class="s1">; 
            } 
        } 
    } 
    </span><span class="s4">return false</span><span class="s1">; 
} 
 
</span><span class="s4">int </span><span class="s1">binary_search_tree::height(node *r) 
{ 
    </span><span class="s4">if</span><span class="s1">(r==NULL) 
        </span><span class="s4">return </span><span class="s5">0</span><span class="s1">; 
    </span><span class="s4">if</span><span class="s1">(r-&gt;LChild==NULL &amp;&amp; r-&gt;RChild==NULL) 
        </span><span class="s4">return </span><span class="s5">0</span><span class="s1">; 
    </span><span class="s4">int </span><span class="s1">hl,hr; 
    hl = height(r-&gt;LChild); 
    hr = height(r-&gt;RChild); 
    </span><span class="s4">if</span><span class="s1">(hl&gt;hr) 
        </span><span class="s4">return </span><span class="s1">hl+</span><span class="s5">1</span><span class="s1">; 
    </span><span class="s4">else</span><span class="s1"> 
        </span><span class="s4">return </span><span class="s1">hr+</span><span class="s5">1</span><span class="s1">; 
} 
 
</span><span class="s4">void </span><span class="s1">binary_search_tree::leaves(node *r) 
{ 
    </span><span class="s4">if</span><span class="s1">(root==NULL) { 
        cout &lt;&lt; </span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Empty Tree!&quot;</span><span class="s1">; 
        </span><span class="s4">return</span><span class="s1">; 
    } 
    </span><span class="s4">if</span><span class="s1">(r!=NULL) 
    { 
        </span><span class="s4">if </span><span class="s1">(r-&gt;LChild == NULL &amp;&amp; r-&gt;RChild == NULL) 
            lCount++; 
        </span><span class="s4">else</span><span class="s1"> 
        { 
            leaves(r-&gt;LChild); 
            leaves(r-&gt;RChild); 
        } 
    } 
} 
 
</span><span class="s4">void </span><span class="s1">binary_search_tree::swap(node *r) 
{ 
    node *temp; 
    </span><span class="s4">if</span><span class="s1">(r!=NULL) 
    { 
        swap(r-&gt;LChild); 
        swap(r-&gt;RChild); 
         
        temp = r-&gt;LChild; 
        r-&gt;LChild = r-&gt;RChild; 
        r-&gt;RChild = temp; 
    } 
} 
 
</span><span class="s4">int </span><span class="s1">main() 
{ 
    binary_search_tree obj; 
    </span><span class="s4">int </span><span class="s1">ch,key; 
    </span><span class="s4">char </span><span class="s1">choice; 
    cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Program to perform Various operation on Binary Search Tree.&quot;</span><span class="s1">; 
    </span><span class="s4">do</span><span class="s1"> 
    { 
        ch = key = </span><span class="s5">0</span><span class="s1">; 
        choice = </span><span class="s3">'n'</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n\n</span><span class="s3">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3"> 1 for Construction and Insertion&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3"> 2 for In order Traversal&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3"> 3 for Pre order Traversal&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3"> 4 for Post order Traversal&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3"> 5 to  Display Root Node&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3"> 6 to  Display No. of Nodes in Tree&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3"> 7 for In order Interative&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3"> 8 for Pre oder Interative&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3"> 9 for Post order Interative&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3"> 10 to Search an Element&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3"> 11 to Remove an Element&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3"> 14 to Find Height of Tree&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3"> 15 to Find Depth of Tree&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3"> 16 to Find No. of Leaves&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3"> 17 to Swap Nodes&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3"> -1 to Clear whole Tree&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">  0 to Quit&quot;</span><span class="s1">; 
        cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Enter your choice : &quot;</span><span class="s1">; 
        cin&gt;&gt;ch; 
        cout&lt;&lt;</span><span class="s3">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s1">; 
        </span><span class="s4">switch</span><span class="s1">(ch) 
        { 
            </span><span class="s4">case </span><span class="s5">1 </span><span class="s1">: obj.construct(); 
                </span><span class="s4">break</span><span class="s1">; 
            </span><span class="s4">case </span><span class="s5">2 </span><span class="s1">: cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">In order Traversal is &quot;</span><span class="s1">; 
                obj.inOrder(obj.retRoot()); 
                </span><span class="s4">break</span><span class="s1">; 
            </span><span class="s4">case </span><span class="s5">3 </span><span class="s1">: cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Pre order Traversal is &quot;</span><span class="s1">; 
                obj.postOrder(obj.retRoot()); 
                </span><span class="s4">break</span><span class="s1">; 
            </span><span class="s4">case </span><span class="s5">4 </span><span class="s1">: cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Post order Traversal is &quot;</span><span class="s1">; 
                obj.preOrder(obj.retRoot()); 
                </span><span class="s4">break</span><span class="s1">; 
            </span><span class="s4">case </span><span class="s5">5 </span><span class="s1">: </span><span class="s4">if</span><span class="s1">(!obj.isEmpty()) 
                    cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Root Node is &quot;</span><span class="s1">&lt;&lt;obj.retRoot()-&gt;data; 
                </span><span class="s4">else</span><span class="s1"> 
                    cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Empty Tree!&quot;</span><span class="s1">; 
                </span><span class="s4">break</span><span class="s1">; 
            </span><span class="s4">case </span><span class="s5">6 </span><span class="s1">: cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">No. of Nodes in Tree are &quot;</span><span class="s1">&lt;&lt;obj.retSize(); 
                </span><span class="s4">break</span><span class="s1">; 
            </span><span class="s4">case </span><span class="s5">7 </span><span class="s1">: cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">In order Interative is &quot;</span><span class="s1">; 
                obj.in_itr(obj.retRoot()); 
                </span><span class="s4">break</span><span class="s1">; 
            </span><span class="s4">case </span><span class="s5">8 </span><span class="s1">: cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Pre order Interative is &quot;</span><span class="s1">; 
                obj.pre_itr(obj.retRoot()); 
                </span><span class="s4">break</span><span class="s1">; 
            </span><span class="s4">case </span><span class="s5">9 </span><span class="s1">: cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Post order Interative is &quot;</span><span class="s1">; 
                obj.post_itr(obj.retRoot()); 
                </span><span class="s4">break</span><span class="s1">; 
            </span><span class="s4">case </span><span class="s5">10 </span><span class="s1">: cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Enter the search term : &quot;</span><span class="s1">; 
                cin&gt;&gt;key; 
                </span><span class="s4">if</span><span class="s1">(obj.search(key)) 
                    cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Key Found!&quot;</span><span class="s1">; 
                </span><span class="s4">else</span><span class="s1"> 
                    cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Key NOT found.&quot;</span><span class="s1">; 
                </span><span class="s4">break</span><span class="s1">; 
            </span><span class="s4">case </span><span class="s5">11 </span><span class="s1">: cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Enter the term to delete : &quot;</span><span class="s1">; 
                cin&gt;&gt;key; 
                obj.remove(key); 
                </span><span class="s4">break</span><span class="s1">; 
            </span><span class="s4">case </span><span class="s5">14 </span><span class="s1">: cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">The Height of tree is &quot;</span><span class="s1">&lt;&lt;obj.height(obj.retRoot()); 
                </span><span class="s4">break</span><span class="s1">; 
            </span><span class="s4">case </span><span class="s5">15 </span><span class="s1">: cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">The Depth of tree is &quot;</span><span class="s1">&lt;&lt;obj.height(obj.retRoot()); 
                </span><span class="s4">break</span><span class="s1">; 
            </span><span class="s4">case </span><span class="s5">16 </span><span class="s1">: cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Total No. of Leaves are &quot;</span><span class="s1">&lt;&lt;obj.retLeaves(); 
                </span><span class="s4">break</span><span class="s1">; 
            </span><span class="s4">case </span><span class="s5">17 </span><span class="s1">: obj.swap(obj.retRoot()); 
                cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Nodes Swapped Successfully!&quot;</span><span class="s1">; 
                </span><span class="s4">break</span><span class="s1">; 
            </span><span class="s4">case </span><span class="s1">-</span><span class="s5">1</span><span class="s1">: cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Are you sure you want to clear tree (y/n) ? &quot;</span><span class="s1">; 
                cin&gt;&gt;choice; 
                </span><span class="s4">if</span><span class="s1">(choice==</span><span class="s3">'y'</span><span class="s1">||choice==</span><span class="s3">'Y'</span><span class="s1">) 
                { 
                    obj.clr(); 
                    cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Tree Cleared Successfully!&quot;</span><span class="s1">; 
                } 
                </span><span class="s4">else</span><span class="s1"> 
                    cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Cancelled!&quot;</span><span class="s1">; 
            </span><span class="s4">case </span><span class="s5">0 </span><span class="s1">: </span><span class="s4">break</span><span class="s1">; 
            </span><span class="s4">default </span><span class="s1">: cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Invalid Option!&quot;</span><span class="s1">; 
        } 
 
        </span><span class="s0">/* 
        if(ch!=0) 
        { 
            cout&lt;&lt;&quot;\n\n\n\n\n\n\nPress any key to continue...&quot;; 
            cin.ignore(); 
            cin.get(); 
        } 
        */</span><span class="s1"> 
    }</span><span class="s4">while</span><span class="s1">(ch!=</span><span class="s5">0</span><span class="s1">); 
 
    cout&lt;&lt;</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Thank you for using this program :) </span><span class="s4">\n\n</span><span class="s3">&quot;</span><span class="s1">; 
    </span><span class="s4">return </span><span class="s5">0</span><span class="s1">; 
} 
 
</span><span class="s0">/* OUTPUT 
 
Program to perform Various operation on Binary Search Tree. 
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 1 for Construction and Insertion 
 2 for In order Traversal 
 3 for Pre order Traversal 
 4 for Post order Traversal 
 5 to  Display Root Node 
 6 to  Display No. of Nodes in Tree 
 7 for In order Interative 
 8 for Pre oder Interative 
 9 for Post order Interative 
 10 to Search an Element 
 11 to Remove an Element 
 14 to Find Height of Tree 
 15 to Find Depth of Tree 
 16 to Find No. of Leaves 
 17 to Swap Nodes 
 -1 to Clear whole Tree 
  0 to Quit 
Enter your choice :1 
 1 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 
Enter value of Node :100 
 100 
 
Root Inserted! 
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 1 for Construction and Insertion 
 2 for In order Traversal 
 3 for Pre order Traversal 
 4 for Post order Traversal 
 5 to  Display Root Node 
 6 to  Display No. of Nodes in Tree 
 7 for In order Interative 
 8 for Pre oder Interative 
 9 for Post order Interative 
 10 to Search an Element 
 11 to Remove an Element 
 14 to Find Height of Tree 
 15 to Find Depth of Tree 
 16 to Find No. of Leaves 
 17 to Swap Nodes 
 -1 to Clear whole Tree 
  0 to Quit 
Enter your choice :1 
 1 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 
Enter value of Node :200 
 200 
 
Element Inserted! 
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 1 for Construction and Insertion 
 2 for In order Traversal 
 3 for Pre order Traversal 
 4 for Post order Traversal 
 5 to  Display Root Node 
 6 to  Display No. of Nodes in Tree 
 7 for In order Interative 
 8 for Pre oder Interative 
 9 for Post order Interative 
 10 to Search an Element 
 11 to Remove an Element 
 14 to Find Height of Tree 
 15 to Find Depth of Tree 
 16 to Find No. of Leaves 
 17 to Swap Nodes 
 -1 to Clear whole Tree 
  0 to Quit 
Enter your choice :1 
 1 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 
Enter value of Node :50 
 50 
 
Element Inserted! 
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 1 for Construction and Insertion 
 2 for In order Traversal 
 3 for Pre order Traversal 
 4 for Post order Traversal 
 5 to  Display Root Node 
 6 to  Display No. of Nodes in Tree 
 7 for In order Interative 
 8 for Pre oder Interative 
 9 for Post order Interative 
 10 to Search an Element 
 11 to Remove an Element 
 14 to Find Height of Tree 
 15 to Find Depth of Tree 
 16 to Find No. of Leaves 
 17 to Swap Nodes 
 -1 to Clear whole Tree 
  0 to Quit 
Enter your choice :1 
 1 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 
Enter value of Node :75 
 75 
 
Element Inserted! 
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 1 for Construction and Insertion 
 2 for In order Traversal 
 3 for Pre order Traversal 
 4 for Post order Traversal 
 5 to  Display Root Node 
 6 to  Display No. of Nodes in Tree 
 7 for In order Interative 
 8 for Pre oder Interative 
 9 for Post order Interative 
 10 to Search an Element 
 11 to Remove an Element 
 14 to Find Height of Tree 
 15 to Find Depth of Tree 
 16 to Find No. of Leaves 
 17 to Swap Nodes 
 -1 to Clear whole Tree 
  0 to Quit 
Enter your choice :2 
 2 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 
In order Traversal is 50,75,100,200, 
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 1 for Construction and Insertion 
 2 for In order Traversal 
 3 for Pre order Traversal 
 4 for Post order Traversal 
 5 to  Display Root Node 
 6 to  Display No. of Nodes in Tree 
 7 for In order Interative 
 8 for Pre oder Interative 
 9 for Post order Interative 
 10 to Search an Element 
 11 to Remove an Element 
 14 to Find Height of Tree 
 15 to Find Depth of Tree 
 16 to Find No. of Leaves 
 17 to Swap Nodes 
 -1 to Clear whole Tree 
  0 to Quit 
Enter your choice :0 
 0 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 
Thank you for using this program :) 
 
*/</span></pre>
</body>
</html>